#include "stdafx.h"
#include "Player.h"
//외부
#include "StageManager.h"
#include "Stage.h"
#include "ObjectManager.h"
#include "EnemyManager.h"
#include "CollisionManager.h"
#include "Enemy.h"
//상태
#include "IPlayerState.h"
#include "playerIdle.h"
#include "playerWait.h"
#include "playerWalk.h"
#include "playerRun.h"
#include "playerJump.h"
#include "playerStick.h"
#include "playerClimb.h"
#include "playerClimbTop.h"
#include "playerPick.h"
#include "playerGrab.h"
#include "playerGuard.h"
#include "playerRoll.h"
#include "playerHit.h"
#include "playerStun.h"
#include "playerStand.h"
#include "playerDown.h"
#include "playerDead.h"
#include "playerThrow.h"
#include "playerStomp.h"
#include "playerCombo1.h"
#include "playerCombo2.h"
#include "playerCombo3.h"
#include "playerSAttack.h"
#include "playerDashAttack.h"
#include "playerDashSAttack.h"
#include "playerJumpAttack.h"
#include "playerSAttackDown.h"

//초기화
HRESULT Player::init()
{
	/*====================================================================
		플래이어의 오브젝트 초기화와 기본 설정을 합니다.
	====================================================================*/
	_obj.init(OBJECT_GROUP::PLAYER, IMG_M->findImage("pl_wait"), vector3(WINSIZEX / 2, 0, WINSIZEY / 2 + 200));

	//기본 변수 초기화
	{
		_info.jumpPower = 0;
		_info.speed = 4.f;
		_info.hasMember = false;
		_info.isDead = false;
		_info.isControl = true;
		_info.isConDest = true;
		_info.isSky = false;
		_info.isAttack = false;
		_info.hasMember = false;
		_info.dest = DIRECTION::RIGHT;
		_info.weaponType = WEAPON_TYPE::BAT;
		_info.moveDest = MOVE_DIRECTION::RIGHT;
		_info.rendType = RENDERTYPE::FRAME_RENDER;
		_info.frameTimer = TIME_M->getWorldTime();
		_obj.ani = new animation;
		_info.hitCount = 3;
	}

	//상태패턴 등록
	{
		_idle = new playerIdle;
		_wait = new playerWait;
		_walk = new playerWalk;
		_run = new playerRun;
		_jump = new playerJump;
		_stick = new playerStick;
		_climb = new playerClimb;
		_climbTop = new playerClimbTop;
		_pick = new playerPick;

		_grab = new playerGrab;
		_guard = new playerGuard;
		_roll = new playerRoll;
		_hit = new playerHit;
		_stun = new playerStun;
		_stand = new playerStand;
		_down = new playerDown;
		_dead = new playerDead;

		_throw = new playerThrow;
		_stomp = new playerStomp;
		_combo1 = new playerCombo1;
		_combo2 = new playerCombo2;
		_combo3 = new playerCombo3;

		_sAttack = new playerSAttack;
		_dashAttack = new playerDashAttack;
		_dashSAttack = new playerDashSAttack;
		_jumpAttack = new playerJumpAttack;
		_SAttackDown = new playerSAttackDown;
	}
	setState(PL_STATE::WAIT);
	return S_OK;
}

void Player::release()
{
}

//업뎃 순서 중요함★ 상태->중력->키입력
void Player::update()
{

	_obj.prePos = _obj.pos;
	_obj.preShadow = _obj.shadow;
	//상태업데이트
	_IState->UpdateState();
	//중력작용
	gravity();
	//키입력
	keyInput();
	//오브젝트 업뎃
	_obj.update();
	//애니프레임 업뎃
	if(_info.rendType == RENDERTYPE::ANI_RENDER)
	_obj.ani->frameUpdate(TIME_M->getElapsedTime() * 7);
	//프레임업뎃
	playFrame();

	if (KEY_M->isOnceKeyDown(VK_NUMPAD0))
	{
		cout << "그림자 LT X: " << _obj.shadow.LT.x << endl;
		cout << "그림자 LT Y: " << _obj.shadow.LT.y << endl;
		cout << "그림자 LT Z: " << _obj.shadow.LT.z << endl;
		cout << "플랫폼 X: " << _platform->bottomPlane[0].getEnd().x << endl;
		cout << "플랫폼 Y: " << _platform->bottomPlane[0].getEnd().y << endl;
		cout << "플랫폼 Z: " << _platform->bottomPlane[0].getEnd().z << endl;
	}

	//공격렉트 갱신
	renewAttackRc();
}

//렌더
void Player::render()
{
	/*====================================================================
		Z-ORDER에 따라 알파 프레임 렌더 시킵니다.
	====================================================================*/

	ZORDER_M->renderObject(getMapDC(), &_obj, _info.rendType);
	Rectangle(getMapDC(), _obj.shadow.rc);
	if(KEY_M->isToggleKey(VK_SHIFT)) Rectangle(getMapDC(), _info.attackInfo.rc);
	if (_info.state == PL_STATE::THROW && _info.dest ==DIRECTION::LEFT)
		_info.attackInfo.img->frameRender(getMapDC(), _info.attackInfo.pos.x, _info.attackInfo.pos.y, 0, 0);
	if (_info.state == PL_STATE::THROW && _info.dest ==DIRECTION::RIGHT)
		_info.attackInfo.img->frameRender(getMapDC(), _info.attackInfo.pos.x, _info.attackInfo.pos.y, 0, 1);
}

//상태 지정
void Player::setState(PL_STATE state)
{
	_info.preState = _info.state; //아마 쓸데 없는데서 따로저장한코드있을거임 나중에 코드정리할때즤워야함
	if (_info.state == state)return; //같은 상태면 변경하지 않는다.
	_info.state = state;
	//상태를 빠져나온다
	if (_IState != NULL)_IState->ExitState();

	//상태를 변경한다
	switch (_info.state)
	{
		//기본동작
	case PL_STATE::IDLE:	    _IState = _idle;		 break;
	case PL_STATE::WAIT:	    _IState = _wait;		 break;
	case PL_STATE::WALK:	    _IState = _walk;		 break;
	case PL_STATE::RUN:		    _IState = _run;			 break;
	case PL_STATE::JUMP:	  
		_info.jumpPower = JUMPPOWERVALUE; 
		_IState = _jump;		 break;
	case PL_STATE::STICK:	    _IState = _stick;		 break;
	case PL_STATE::CLIMB:      _IState = _climb;		 break;
	case PL_STATE::CLIMBTOP:   _IState = _climbTop;		 break;
	case PL_STATE::PICK:      _IState = _pick;			 break;
		//가드 및 피격
	case PL_STATE::GRAB:       _IState = _grab;			break;
	case PL_STATE::GUARD:       _IState = _guard;		 break;
	case PL_STATE::ROLL:       _IState = _roll;			 break;
	case PL_STATE::HIT:		    _IState = _hit;			 break;
	case PL_STATE::STUN:        _IState = _stun;		 break;
	case PL_STATE::STAND:		_IState = _stand;
		_info.hitCount = 3;
		break;
	case PL_STATE::DOWN:	    _IState = _down;		 break;
	case PL_STATE::DEAD:	    _IState = _dead;		 break;
		// 공격
	case PL_STATE::THROW:	    _IState = _throw;		 break;
	case PL_STATE::STOMP:	    _IState = _stomp;		 break;
	case PL_STATE::COMBO1:	    _IState = _combo1;		 break;
	case PL_STATE::COMBO2:	    _IState = _combo2;		 break;
	case PL_STATE::COMBO3:	    _IState = _combo3;		 break;
	case PL_STATE::SATTACK:     _IState = _sAttack;		 break;
	case PL_STATE::DASHATTACK:  _IState = _dashAttack;	 break;
	case PL_STATE::DASHSATTACK: _IState = _dashSAttack;  break;
	case PL_STATE::JUMPATTACK:  _IState = _jumpAttack;	 break;
	case PL_STATE::SATTACKDOWN: _IState = _SAttackDown;  break;
	default: break;
	}

	//상태 링크
	_IState->LinkPlAddress(this);
	_IState->EnterState();
}

//같은 줄 유무
bool Player::isRange(GameObject obj)
{
	//위치 차이가 3미만이면
	if (abs(_obj.pos.z - obj.pos.z) < 15)
	{
		return true;
	}
	return false;
}

//같은 줄 유무
bool Player::isRange(GameObject obj,float value)
{
	//위치 차이가 3미만이면
	if (abs(_obj.pos.z - obj.pos.z) < value)
	{
		return true;
	}
	return false;
}

//스테이지가 바뀔 때마다 초기화시키는 함수
void Player::stageInit()
{
	/*====================================================================
		스테이지가 바뀔 때마다 초기화시키는 함수입니다.
	====================================================================*/
	switch (_stageM->getCurStage()) // 현재 스테이지는?
	{
	case STAGETYPE::EASY: // 현재 스테이지가 이지면
		if (_stageM->getPreStage() == STAGETYPE::NORMAL) // 이전 스테이지가 노말이였으면
		{
			_obj.setPosX(1445);
			_obj.setPosY(0);
			_obj.setPosZ(420);
		}
		break;
	case STAGETYPE::NORMAL:  // 현재 스테이지가 노말이면
		if (_stageM->getPreStage() == STAGETYPE::EASY) // 이전 스테이지가 노말이였으면
		{
			_obj.setPosX(180);
			_obj.setPosY(0);
			_obj.setPosZ(700);
		}
		else if (_stageM->getPreStage() == STAGETYPE::HARD) // 이전 스테이지가 하드이였으면
		{
			_obj.setPosX(2645);
			_obj.setPosY(0);
			_obj.setPosZ(670);
		}
		break;
	case STAGETYPE::HARD: // 현재 스테이지가 하드면
		if (_stageM->getPreStage() == STAGETYPE::NORMAL) // 이전 스테이지가 노말이였으면
		{
			_obj.setPosX(270);
			_obj.setPosY(0); // 나중에 추가해야함
			_obj.setPosZ(480);
		}
		else if (_stageM->getPreStage() == STAGETYPE::BOSS) // 이전 스테이지가 보스였으면
		{
			_obj.setPosX(2070);
			_obj.setPosY(0);
			_obj.setPosZ(1370);
		}
		break;
	case STAGETYPE::BOSS: // 현재 스테이지가 보스면
		if (_stageM->getPreStage() == STAGETYPE::HARD) // 이전 스테이지가 하드이였으면
		{
			_obj.setPosX(275);
			_obj.setPosY(0);
			_obj.setPosZ(605);
		}
		break;
	default:
		break;
	}

	/*====================================================================
		링크 : 에너미매니저, 오브젝트 매니저와 링크합니다.
	====================================================================*/
	_enemyM = _stageM->getStage()->getEnemyM();
	_objectM = _stageM->getStage()->getObjectM();
}

//이미지 변경
void Player::changeImg(string imgName, bool reverse)
{
	//이미지를 바꾼다.
	_obj.img = IMG_M->findImage(imgName);
	//프레임 시간 갱신하여 바로 프레임 변경
	_info.frameTimer = TIME_M->getWorldTime();
	//방향과 리버스 여부 따른 프레임 x 인덱스 설정
	switch (_info.dest)
		{
		case DIRECTION::LEFT:
			if(!reverse)_obj.imgIndex.x = 0;
			else if(reverse)_obj.imgIndex.x = _obj.img->getMaxFrameX(); 
			_obj.imgIndex.y = 0;
			break;
			
		case DIRECTION::RIGHT:
			if (!reverse)_obj.imgIndex.x = _obj.img->getMaxFrameX(); 
			else if (reverse)_obj.imgIndex.x =0;
			_obj.imgIndex.y = 1;
			break;
		}
	
}

//프레임 연산
void Player::setFrame(FRAMETYPE frameType, float frameInterval)
{
	//프레임 y 번호 설정
	switch (_info.dest)
	{
	case DIRECTION::LEFT:
		_obj.imgIndex.y = 0;
		break;
	case DIRECTION::RIGHT:
		_obj.imgIndex.y = 1;
		break;
	}
	if(_info.state == PL_STATE::CLIMB || _info.state == PL_STATE::CLIMBTOP)
		_obj.imgIndex.y = 0;
	//프레임 y 번호 세팅
	_obj.img->setFrameY((int)_info.dest);

	//프레임 실행 시간 설정
	if (TIME_M->getWorldTime() - _info.frameTimer > frameInterval)
	{
		//시간 갱신
		_info.frameTimer = TIME_M->getWorldTime();
		switch (_info.dest)
		{
		case DIRECTION::LEFT:
			if (frameType != FRAMETYPE::REVERSEROOP && frameType != FRAMETYPE::REVERSEONCE) ++_obj.imgIndex.x;
			else --_obj.imgIndex.x;


			break;
		case DIRECTION::RIGHT:
			if (frameType != FRAMETYPE::REVERSEROOP&& frameType != FRAMETYPE::REVERSEONCE) --_obj.imgIndex.x;
			else  ++_obj.imgIndex.x;
			break;
		}
	}

	//프레임 x 번호 조절
	switch (frameType)
	{
	case FRAMETYPE::ONCE://한 번 재생
		{
		//왼쪽의 경우 x인덱스가 0번부터~ 끝번까지 프레임이 다 되면 끝번호로 프레임번호 고정
		if (_info.dest == DIRECTION::LEFT && _obj.imgIndex.x > _obj.img->getMaxFrameX())
		{
			_obj.imgIndex.x = _obj.img->getMaxFrameX(); 
		}
		//오른쪽의 경우 x인덱스가 끝번부터 0번까지 프레임이 다 되면 0번으로 프레임 번호 고정
		else if (_info.dest == DIRECTION::RIGHT && _obj.imgIndex.x < 0)
		{
			_obj.imgIndex.x = 0; 
		}
			
		}
		break;
	case FRAMETYPE::LOOP://무한 재생
		{
		//왼쪽의 경우 x인덱스가 0번부터~ 끝번까지 프레임이 다 되면 끝번호로 프레임번호 0번으로 갱신
		if (_info.dest == DIRECTION::LEFT && _obj.imgIndex.x > _obj.img->getMaxFrameX())
			_obj.imgIndex.x = 0;

		//오른쪽의 경우 x인덱스가 끝번부터 0번까지 프레임이 다 되면 0번으로 프레임 번호 끝번호로 갱신
		else if (_info.dest == DIRECTION::RIGHT && _obj.imgIndex.x < 0)
			_obj.imgIndex.x = _obj.img->getMaxFrameX();
		}
		break;
	case FRAMETYPE::REVERSEONCE://반대 한번 재생
		{
		if (_info.dest == DIRECTION::RIGHT && _obj.imgIndex.x > _obj.img->getMaxFrameX())
		{
			_obj.imgIndex.x = _obj.img->getMaxFrameX(); return;
		}
		else if (_info.dest == DIRECTION::LEFT && _obj.imgIndex.x < 0)
		{
			_obj.imgIndex.x = 0; return;
		}
		}
		break;
	case FRAMETYPE::REVERSEROOP://반대 무한 재생
		{
		if (_info.dest == DIRECTION::RIGHT && _obj.imgIndex.x > _obj.img->getMaxFrameX())
			_obj.imgIndex.x = 0;

		else if (_info.dest == DIRECTION::LEFT && _obj.imgIndex.x < 0)
			_obj.imgIndex.x = _obj.img->getMaxFrameX();
		
		}
		break;
	}

}

//프레임 실행
void Player::playFrame()
{
	switch (_info.state)
	{
	//무한재생 (일반 속도)
	case PL_STATE::WAIT:	

		setFrame(FRAMETYPE::LOOP, FRAMEINTERVAL);
		_info.rendType = RENDERTYPE::FRAME_RENDER;
		break;
	//반대 무한재생 (빨리)
	case PL_STATE::RUN:
		setFrame(FRAMETYPE::REVERSEROOP, FRAMEINTERVAL*0.35);
		break;
	//반대 무한재생
	case PL_STATE::STUN:
	case PL_STATE::IDLE:	case PL_STATE::WALK:
		setFrame(FRAMETYPE::REVERSEROOP, FRAMEINTERVAL);
		break;

	//한번 (천천히)
	case PL_STATE::PICK:	case PL_STATE::GRAB:					 
	case PL_STATE::STICK:	case PL_STATE::HIT:
		setFrame(FRAMETYPE::ONCE, FRAMEINTERVAL*3);
	case PL_STATE::CLIMBTOP:
		setFrame(FRAMETYPE::ONCE, FRAMEINTERVAL * 5);
		_info.rendType = RENDERTYPE::FRAME_RENDER;
		break;
	//한번 (일반 속도)
	case PL_STATE::JUMP:	
	case PL_STATE::ROLL:
	case PL_STATE::STAND:
	case PL_STATE::DOWN:	case PL_STATE::DEAD:
	case PL_STATE::THROW:	
	case PL_STATE::COMBO1:	case PL_STATE::COMBO2:		
	case PL_STATE::COMBO3:	case PL_STATE::SATTACK:
	case PL_STATE::DASHSATTACK:
	 case PL_STATE::JUMPATTACK: 
		setFrame(FRAMETYPE::ONCE, FRAMEINTERVAL);	
		_info.rendType = RENDERTYPE::FRAME_RENDER;
		break;
	//반대 한번재생 (일반 속도)
	 case PL_STATE::STOMP:
	case PL_STATE::DASHATTACK:	case PL_STATE::SATTACKDOWN:
		setFrame(FRAMETYPE::REVERSEONCE, FRAMEINTERVAL);
		_info.rendType = RENDERTYPE::FRAME_RENDER;
		break;
	//반대 한번재생 (빨리)
	case PL_STATE::GUARD:
		setFrame(FRAMETYPE::REVERSEONCE, FRAMEINTERVAL*0.4);
		_info.rendType = RENDERTYPE::FRAME_RENDER;
		break;
	//애니랜더
	case PL_STATE::CLIMB:
		_info.rendType = RENDERTYPE::ANI_RENDER;
		_obj.ani->setFPS(1);
		break;
	}

}

//좌표이동
void Player::movePos(float x, float z, float jumpPower)
{
	_obj.pos.x += x;
	_obj.pos.z += z;
	_obj.pos.y -= jumpPower;

	//그림자만 일단 한번 업데이트 (충돌처리를 위한거! 건드리면 안됨!)
	_obj.shadowUpdate();
	//충돌처리 
	_colM->objectCollision();

	//그림자 아래로 안 떨어지도록 예외처리
	if (_obj.pos.y > 0)_obj.pos.y = 0;

	//최종 렉트 갱신
	_obj.update();
}

//공격렉트 갱신
void Player::renewAttackRc()
{
	//무기에 따른 렉트 크기 설정
	switch (_info.weaponType)
	{
	case WEAPON_TYPE::NONE:
		_info.attackInfo.width = ATTACKSIZE *0.4; break;
	case WEAPON_TYPE::BAT:	case WEAPON_TYPE::BASEBALL:
		_info.attackInfo.img = IMG_M->findImage("bat");
		_info.attackInfo.width = IMG_M->findImage("bat")->getFrameWidth(); break;
	}
	 
	//상황에 따른 렉트 크기 설정
	_info.attackInfo.height = ATTACKSIZE/2;
	switch (_info.state)
	{
	case PL_STATE::IDLE:_info.attackInfo.height = ATTACKSIZE / 2; break;
	case PL_STATE::JUMPATTACK:_info.attackInfo.height = ATTACKSIZE; break;
	case PL_STATE::THROW:
		_info.attackInfo.width = IMG_M->findImage("bat")->getFrameWidth();
		_info.attackInfo.height = IMG_M->findImage("bat")->getFrameHeight();
			break;
	case PL_STATE::SATTACKDOWN:_info.attackInfo.width = ATTACKSIZE*0.7; break;
	}

	//무기를 날리는게 아닐경우
	if (_info.state != PL_STATE::THROW)
	{
		//방향에따라 공격 렉트 위치 갱신
		switch (_info.dest)
		{
		case DIRECTION::LEFT:
			_info.attackInfo.pos.x = _obj.pos.x - (_obj.rc.right  - _obj.rc.left)/2;break;
		case DIRECTION::RIGHT:
			_info.attackInfo.pos.x = _obj.pos.x + (_obj.rc.right - _obj.rc.left) / 2;break;
		}
		//상황에 따른 렉트 위치 갱신
		//★ 커맨드 공격의 경우 가운데여야함
		_info.attackInfo.pos.y = (_obj.rc.bottom + _obj.rc.top)/2;

		switch (_info.state)
		{
		case PL_STATE::SATTACKDOWN:_info.attackInfo.pos.x = _obj.pos.x ; break;
		}
	}
	//무기를 날릴 경우
	else if(_info.state == PL_STATE::THROW && _info.dest == DIRECTION::LEFT)_info.attackInfo.pos.x -= THROWSPEED;
	else if(_info.state == PL_STATE::THROW&& _info.dest == DIRECTION::RIGHT)_info.attackInfo.pos.x += THROWSPEED;

	//렉트 갱신
	_info.attackInfo.rc = RectMakeCenter(_info.attackInfo.pos.x, _info.attackInfo.pos.y, _info.attackInfo.width, _info.attackInfo.height);

}

//중력작용
void Player::gravity()
{
	if (_info.isSky) _info.jumpPower -= GRAVITYVALUE;
	if (_obj.pos.y >= 0 && _info.isSky == true)
	{
		setState(PL_STATE::IDLE);
		//걷거나 뛰고있었고, 키를 계속 누르고있으면 그 상태 그대로돌아오기
		if (_info.preState == PL_STATE::WALK || _info.preState == PL_STATE::RUN)
		{
			if(_info.dest == DIRECTION::LEFT)
				if(KEY_M->isStayKeyDown(VK_LEFT))setState(_info.preState); 
			if (_info.dest == DIRECTION::RIGHT)
				if (KEY_M->isStayKeyDown(VK_RIGHT))setState(_info.preState); 
		}
		_info.isSky = false;
		_platform = nullptr;
	}
	if (_obj.pos.y > 0) _info.jumpPower = 0;
	movePos(0, 0, _info.jumpPower);
}

//키입력
void Player::keyInput()
{

	//키조작을 못하는 상태라면 리턴
	if (!_info.isControl)return;

	//공격키받기(커맨드를위해)
	if (KEY_M->isOnceKeyDownV('D'));

	//점프
	if (KEY_M->isOnceKeyDownV('A')&& !_info.isSky)
	{
		//이전상태 저장
		_info.preState = _info.state;
		_info.isSky = true;
		_info.jumpPower = JUMPPOWERVALUE;
		movePos(0, 0, JUMPPOWERVALUE);
	//점프파워가 - 면 점프상태로 전환
	if(_info.jumpPower > 0.4)setState(PL_STATE::JUMP);
	}
	//구르기
	if (KEY_M->isOnceKeyDownV('W') && !_info.isSky)
	{
		//이전상태 저장
		_info.preState = _info.state;
		setState(PL_STATE::ROLL);
	}

	//방향조작을 못하는 상태라면 리턴
	if (!_info.isConDest)return;

	//왼
	if (KEY_M->isOnceKeyDownV(VK_LEFT) || KEY_M->isStayKeyDown(VK_LEFT))
	{
		_info.moveDest = MOVE_DIRECTION::LEFT;
		_info.dest = DIRECTION::LEFT;
	}
	//오
	if (KEY_M->isOnceKeyDownV(VK_RIGHT) || KEY_M->isStayKeyDown(VK_RIGHT))
	{
		_info.moveDest = MOVE_DIRECTION::RIGHT;
		_info.dest = DIRECTION::RIGHT;
	}
	//위
	if (KEY_M->isOnceKeyDownV(VK_UP) || KEY_M->isStayKeyDown(VK_UP))_info.moveDest = MOVE_DIRECTION::UP;
	//아래
	if (KEY_M->isOnceKeyDownV(VK_DOWN) || KEY_M->isStayKeyDown(VK_DOWN))_info.moveDest = MOVE_DIRECTION::DOWN;


	//키커맨드 
	if (!_info.isSky && KEY_M->getVKeyBuffer().size() >= 3)
	{
		//바라보는 방향키+ ↓ + d 커맨드 공격
		if (KEY_M->getKeyBuffer(0) == 'D' &&KEY_M->getKeyBuffer(1) == VK_DOWN
			&& KEY_M->getKeyBuffer(2) == VK_RIGHT && _info.dest == DIRECTION::RIGHT)
			setState(PL_STATE::SATTACKDOWN);

		if (KEY_M->getKeyBuffer(0) == 'D' &&KEY_M->getKeyBuffer(1) == VK_DOWN
			&& KEY_M->getKeyBuffer(2) == VK_LEFT && _info.dest == DIRECTION::LEFT)
			setState(PL_STATE::SATTACKDOWN);

	}
}

